# å®‰å…¨æ€§æ”¹è¿›å®æ–½æŒ‡å—

## 1. å‡çº§å¯†ç å“ˆå¸Œç®—æ³•ï¼ˆå¿…é¡»ï¼‰

### å½“å‰é—®é¢˜
ä½¿ç”¨ SHA-256 ä¸å®‰å…¨ï¼Œå®¹æ˜“è¢«æš´åŠ›ç ´è§£å’Œå½©è™¹è¡¨æ”»å‡»ã€‚

### è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨ bcrypt

#### æ­¥éª¤ 1: æ›´æ–° Cargo.toml

```toml
# åœ¨ src-tauri/Cargo.toml çš„ [dependencies] éƒ¨åˆ†æ·»åŠ ï¼š
bcrypt = "0.15"
```

#### æ­¥éª¤ 2: æ›´æ–° src-tauri/src/utils/crypto.rs

```rust
use bcrypt::{hash, verify, DEFAULT_COST};

/// Hash password using bcrypt (æ›´å®‰å…¨)
pub fn hash_password(password: &str) -> Result<String, String> {
    hash(password, DEFAULT_COST)
        .map_err(|e| format!("å¯†ç åŠ å¯†å¤±è´¥: {}", e))
}

/// Verify password against bcrypt hash
pub fn verify_password(password: &str, hash: &str) -> bool {
    verify(password, hash).unwrap_or(false)
}
```

#### æ­¥éª¤ 3: æ›´æ–° src-tauri/src/commands/auth.rs

```rust
// åœ¨ register å‡½æ•°ä¸­ä¿®æ”¹
// Hash password
let password_hash = hash_password(&data.password)
    .map_err(|e| format!("å¯†ç å¤„ç†å¤±è´¥: {}", e))?;  // æ·»åŠ é”™è¯¯å¤„ç†
```

#### æ­¥éª¤ 4: æ•°æ®è¿ç§»

**é‡è¦ï¼š**ç°æœ‰ç”¨æˆ·çš„å¯†ç éœ€è¦é‡æ–°å“ˆå¸Œã€‚æœ‰ä¸¤ä¸ªé€‰æ‹©ï¼š

**é€‰é¡¹Aï¼šå¼ºåˆ¶æ‰€æœ‰ç”¨æˆ·é‡ç½®å¯†ç **
```sql
-- åœ¨ Supabase æ‰§è¡Œ
UPDATE users SET password_hash = 'NEEDS_RESET';
```

ç„¶ååœ¨ç™»å½•æ—¶æ£€æµ‹å¹¶è¦æ±‚é‡ç½®ã€‚

**é€‰é¡¹Bï¼šæ¸è¿›å¼è¿ç§»**
```rust
// åœ¨ login å‡½æ•°ä¸­æ·»åŠ æ£€æµ‹é€»è¾‘
if user.password_hash.len() == 64 {  // SHA-256 çš„é•¿åº¦
    // æ—§çš„ SHA-256 hashï¼Œä½¿ç”¨æ—§æ–¹æ³•éªŒè¯
    if old_verify_password(&credentials.password, &user.password_hash) {
        // éªŒè¯æˆåŠŸï¼Œæ›´æ–°ä¸ºæ–°çš„ bcrypt hash
        let new_hash = hash_password(&credentials.password)?;
        // æ›´æ–°æ•°æ®åº“...
    }
} else {
    // æ–°çš„ bcrypt hash
    if !verify_password(&credentials.password, &user.password_hash) {
        return Err("ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯".to_string());
    }
}
```

---

## 2. å®ç° JWT Tokenï¼ˆå¼ºçƒˆå»ºè®®ï¼‰

### å½“å‰é—®é¢˜
Token ä½¿ç”¨ç®€å•çš„å­—ç¬¦ä¸²æ‹¼æ¥ï¼Œå®¹æ˜“è¢«ä¼ªé€ ã€‚

### è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨ JWT

#### æ­¥éª¤ 1: æ·»åŠ ä¾èµ–

```toml
# src-tauri/Cargo.toml
jsonwebtoken = "9.0"
uuid = { version = "1.0", features = ["v4"] }
```

#### æ­¥éª¤ 2: åˆ›å»º JWT å·¥å…·

åˆ›å»ºæ–‡ä»¶ `src-tauri/src/utils/jwt.rs`:

```rust
use jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey};
use serde::{Deserialize, Serialize};
use chrono::{Utc, Duration};

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: i32,           // user_id
    pub username: String,
    pub is_admin: bool,
    pub exp: i64,           // è¿‡æœŸæ—¶é—´
    pub iat: i64,           // ç­¾å‘æ—¶é—´
}

// åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œä»ç¯å¢ƒå˜é‡è¯»å–
const JWT_SECRET: &str = "your-secret-key-min-32-chars-long-please-change-in-production";

pub fn create_token(user_id: i32, username: String, is_admin: bool) -> Result<String, String> {
    let now = Utc::now();
    let exp = now + Duration::hours(24); // 24å°æ—¶è¿‡æœŸ
    
    let claims = Claims {
        sub: user_id,
        username,
        is_admin,
        exp: exp.timestamp(),
        iat: now.timestamp(),
    };
    
    encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(JWT_SECRET.as_ref())
    )
    .map_err(|e| format!("Tokenç”Ÿæˆå¤±è´¥: {}", e))
}

pub fn verify_token(token: &str) -> Result<Claims, String> {
    decode::<Claims>(
        token,
        &DecodingKey::from_secret(JWT_SECRET.as_ref()),
        &Validation::default()
    )
    .map(|data| data.claims)
    .map_err(|e| format!("TokenéªŒè¯å¤±è´¥: {}", e))
}
```

#### æ­¥éª¤ 3: æ›´æ–° utils/mod.rs

```rust
pub mod crypto;
pub mod time;
pub mod jwt;  // æ·»åŠ è¿™è¡Œ
```

#### æ­¥éª¤ 4: åœ¨ auth.rs ä¸­ä½¿ç”¨

```rust
use crate::utils::jwt::create_token;

#[tauri::command]
pub async fn login(
    credentials: LoginRequest,
    db: State<'_, SupabaseClient>,
) -> Result<LoginResponse, String> {
    // ... ç°æœ‰çš„éªŒè¯é€»è¾‘ ...
    
    // ç”Ÿæˆ JWT token
    let token = create_token(user.id, user.username.clone(), user.is_admin)?;
    
    Ok(LoginResponse { user, token })
}
```

---

## 3. æ·»åŠ è¾“å…¥éªŒè¯ï¼ˆå¼ºçƒˆå»ºè®®ï¼‰

### åˆ›å»ºéªŒè¯å·¥å…·

åˆ›å»ºæ–‡ä»¶ `src-tauri/src/utils/validation.rs`:

```rust
use regex::Regex;

pub fn validate_username(username: &str) -> Result<(), String> {
    if username.len() < 3 {
        return Err("ç”¨æˆ·åè‡³å°‘éœ€è¦3ä¸ªå­—ç¬¦".to_string());
    }
    if username.len() > 50 {
        return Err("ç”¨æˆ·åæœ€å¤š50ä¸ªå­—ç¬¦".to_string());
    }
    
    // åªå…è®¸å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿
    let re = Regex::new(r"^[a-zA-Z0-9_]+$").unwrap();
    if !re.is_match(username) {
        return Err("ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿".to_string());
    }
    
    Ok(())
}

pub fn validate_password(password: &str) -> Result<(), String> {
    if password.len() < 6 {
        return Err("å¯†ç è‡³å°‘éœ€è¦6ä¸ªå­—ç¬¦".to_string());
    }
    if password.len() > 100 {
        return Err("å¯†ç æœ€å¤š100ä¸ªå­—ç¬¦".to_string());
    }
    
    // å¯é€‰ï¼šè¦æ±‚åŒ…å«å¤§å°å†™å­—æ¯å’Œæ•°å­—
    // let has_upper = password.chars().any(|c| c.is_uppercase());
    // let has_lower = password.chars().any(|c| c.is_lowercase());
    // let has_digit = password.chars().any(|c| c.is_numeric());
    // 
    // if !has_upper || !has_lower || !has_digit {
    //     return Err("å¯†ç å¿…é¡»åŒ…å«å¤§å°å†™å­—æ¯å’Œæ•°å­—".to_string());
    // }
    
    Ok(())
}

pub fn validate_full_name(name: &str) -> Result<(), String> {
    if name.trim().is_empty() {
        return Err("å§“åä¸èƒ½ä¸ºç©º".to_string());
    }
    if name.len() > 100 {
        return Err("å§“åæœ€å¤š100ä¸ªå­—ç¬¦".to_string());
    }
    Ok(())
}
```

### åœ¨ auth.rs ä¸­ä½¿ç”¨

```rust
use crate::utils::validation::{validate_username, validate_password, validate_full_name};

#[tauri::command]
pub async fn register(
    data: RegisterRequest,
    db: State<'_, SupabaseClient>,
) -> Result<User, String> {
    // è¾“å…¥éªŒè¯
    validate_username(&data.username)?;
    validate_password(&data.password)?;
    validate_full_name(&data.full_name)?;
    
    // ... ç°æœ‰çš„æ³¨å†Œé€»è¾‘ ...
}
```

---

## 4. ç¯å¢ƒå˜é‡å®‰å…¨ç®¡ç†

### æ­¥éª¤ 1: ç¡®ä¿ .env ä¸è¢«æäº¤

```bash
# æ£€æŸ¥ .gitignore æ˜¯å¦åŒ…å«
cat .gitignore | grep .env

# å¦‚æœ .env å·²ç»è¢«æäº¤ï¼Œä» git å†å²ä¸­ç§»é™¤
git rm --cached .env
git commit -m "Remove .env from repository"
```

### æ­¥éª¤ 2: åˆ›å»ºç¯å¢ƒå˜é‡æ¨¡æ¿

æ›´æ–° `.env.example`:

```bash
# Supabase é…ç½®
# è¯·å°†ä¸‹é¢çš„å€¼æ›¿æ¢ä¸ºæ‚¨çš„å®é™… Supabase é¡¹ç›®å‡­æ®
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_KEY=your-anon-key-here

# JWT å¯†é’¥ï¼ˆè‡³å°‘32ä¸ªå­—ç¬¦ï¼‰
# åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨éšæœºç”Ÿæˆçš„å¯†é’¥ï¼
JWT_SECRET=your-secret-key-at-least-32-characters-long

# åº”ç”¨é…ç½®
APP_ENV=production
LOG_LEVEL=info
```

### æ­¥éª¤ 3: ç”Ÿæˆå®‰å…¨çš„å¯†é’¥

```bash
# ç”Ÿæˆéšæœº JWT å¯†é’¥
openssl rand -base64 32
```

---

## 5. é”™è¯¯å¤„ç†æ”¹è¿›

### å…¨å±€é”™è¯¯å¤„ç†å™¨

åœ¨ `src-tauri/src/main.rs` ä¸­æ·»åŠ ï¼š

```rust
use std::panic;

fn setup_panic_hook() {
    panic::set_hook(Box::new(|panic_info| {
        let payload = panic_info.payload();
        let message = if let Some(s) = payload.downcast_ref::<&str>() {
            s
        } else if let Some(s) = payload.downcast_ref::<String>() {
            s.as_str()
        } else {
            "Unknown panic"
        };
        
        eprintln!("Application panic: {}", message);
        // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ—¥å¿—è®°å½•
    }));
}

fn main() {
    setup_panic_hook();
    
    // ... ç°æœ‰ä»£ç  ...
}
```

---

## 6. å‰ç«¯é”™è¯¯å¤„ç†

### åˆ›å»ºé”™è¯¯è¾¹ç•Œç»„ä»¶

åˆ›å»º `src/components/ErrorBoundary.tsx`:

```tsx
import React, { Component, ReactNode } from 'react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('ErrorBoundary caught error:', error, errorInfo);
    // å¯ä»¥åœ¨è¿™é‡Œå‘é€é”™è¯¯æŠ¥å‘Š
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-100">
          <div className="bg-white p-8 rounded-lg shadow-lg max-w-md">
            <h2 className="text-2xl font-bold text-red-600 mb-4">å‡ºé”™äº†</h2>
            <p className="text-gray-600 mb-4">
              åº”ç”¨é‡åˆ°äº†æ„å¤–é”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚
            </p>
            <button
              onClick={() => window.location.reload()}
              className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
            >
              åˆ·æ–°é¡µé¢
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### åœ¨ App.tsx ä¸­ä½¿ç”¨

```tsx
import { ErrorBoundary } from './components/ErrorBoundary';

function App() {
  return (
    <ErrorBoundary>
      {/* ç°æœ‰å†…å®¹ */}
    </ErrorBoundary>
  );
}
```

---

## å®æ–½ä¼˜å…ˆçº§

### ğŸ”´ ç«‹å³å®æ–½ï¼ˆä¸Šçº¿å‰å¿…é¡»ï¼‰
1. âœ… å‡çº§å¯†ç å“ˆå¸Œåˆ° bcrypt
2. âœ… æ·»åŠ è¾“å…¥éªŒè¯
3. âœ… ç§»é™¤æ•æ„Ÿæ—¥å¿—

### ğŸŸ¡ å°½å¿«å®æ–½ï¼ˆä¸Šçº¿åä¸€å‘¨å†…ï¼‰
1. âœ… å®ç° JWT Token
2. âœ… æ·»åŠ å…¨å±€é”™è¯¯å¤„ç†
3. âœ… å®Œå–„ç¯å¢ƒå˜é‡ç®¡ç†

### ğŸŸ¢ è®¡åˆ’å®æ–½ï¼ˆä¸€ä¸ªæœˆå†…ï¼‰
1. æ·»åŠ å®¡è®¡æ—¥å¿—
2. å®ç° 2FA åŒå› ç´ è®¤è¯
3. æ·»åŠ  API é€Ÿç‡é™åˆ¶

---

## æµ‹è¯•éªŒè¯

å®Œæˆæ”¹è¿›åï¼Œæ‰§è¡Œä»¥ä¸‹æµ‹è¯•ï¼š

```bash
# 1. æµ‹è¯•æ³¨å†Œï¼ˆåº”è¯¥éªŒè¯è¾“å…¥ï¼‰
# 2. æµ‹è¯•ç™»å½•ï¼ˆåº”è¯¥è¿”å› JWTï¼‰
# 3. æµ‹è¯•é”™è¯¯æƒ…å†µï¼ˆæ— æ•ˆè¾“å…¥ç­‰ï¼‰
# 4. æµ‹è¯•å¯†ç å“ˆå¸Œï¼ˆæ–°æ³¨å†Œçš„ç”¨æˆ·ï¼‰
# 5. å‹åŠ›æµ‹è¯•ï¼ˆ100+ å¹¶å‘è¯·æ±‚ï¼‰
```

---

## å›æ»šè®¡åˆ’

å¦‚æœæ›´æ–°å‡ºç°é—®é¢˜ï¼š

1. ä¿ç•™æ—§ç‰ˆæœ¬çš„ `crypto.rs` å¤‡ä»½
2. æ•°æ®åº“å¤‡ä»½ä¿ç•™æœ€è¿‘7å¤©
3. å‡†å¤‡å¿«é€Ÿå›æ»šè„šæœ¬
4. é€šçŸ¥ç”¨æˆ·ç»´æŠ¤æ—¶é—´

